# 各种排序总结

来源：[https://segmentfault.com/a/1190000011294349](https://segmentfault.com/a/1190000011294349)

## Array.sort()

```javascript
const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 100, 50];

console.log(arr.sort());   //[ 1, 10, 100, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88 ]

console.log(arr.sort((item1, item2) => item1 - item2)); //[ 1, 10, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88, 100 ]
```

sort函数的性能：相信对于排序算法性能来说，时间复杂度是至关重要的一个参考因素。那么，sort函数的算法性能如何呢？通过v8引擎的源码可以看出，Array.sort是通过javascript来实现的，而使用的算法是快速排序，但是从源码的角度来看，在实现上明显比我们所使用的快速排序复杂多了，主要是做了性能上的优化。所以，我们可以放心的使用sort()进行排序。

## 冒泡排序

思路：第一次循环，开始比较当前元素与下一个元素的大小，如果比下一个元素小或者相等，则不需要交换两个元素的值；若比下一个元素大的话，则交换两个元素的值。然后，遍历整个数组，第一次遍历完之后，相同操作遍历第二遍。

![](https://segmentfault.com/img/remote/1460000011294354)

```javascript
const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 100, 50];

function bubbleSort(arr){
  for(let i = 0; i < arr.length - 1; i++){
    for(let j = 0; j < arr.length - i - 1; j++){
      if(arr[j] > arr[j + 1]){
        swap(arr, j, j+1);
      }
    }
  }
  return arr;
}

function swap(arr, i, j){
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
console.log(arr);
```

### 性能：

时间复杂度：平均时间复杂度是O(n^2)
空间复杂度：由于辅助空间为常数，所以空间复杂度是O(1);

### 改进：

我们可以对冒泡排序进行改进，使得它的时间复杂度在大多数顺序的情况下，减小到O(n);

加一个标志位，如果没有进行交换，将标志位置为false，表示排序完成。

```javascript
const arr = [1, 20, 10, 30, 22, 11, 55, 24, 31, 88, 12, 100, 50];

function swap(arr, i, j){
  const temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

for(let i = 0; i < arr.length - 1; i++){
  let flag = false;
  for(let j = 0; j < arr.length - 1 - i; j++){
    if(arr[j] > arr[j+1]){
      swap(arr, j, j+1);
      flag = true;
    }
  }

  if(!flag){
    break;
  }
}

console.log(arr);  //[ 1, 10, 11, 12, 20, 22, 24, 30, 31, 50, 55, 88, 100 ]
```
